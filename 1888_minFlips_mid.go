package leetcode_go

// 给你一个二进制字符串 s 。你可以按任意顺序执行以下两种操作任意次：
//
// 类型 1 ：删除 字符串 s 的第一个字符并将它 添加 到字符串结尾。
// 类型 2 ：选择 字符串 s 中任意一个字符并将该字符 反转 ，也就是如果值为 '0' ，则反转得到 '1' ，反之亦然。
// 请你返回使 s 变成 交替 字符串的前提下， 类型 2 的 最少 操作次数 。
//
// 我们称一个字符串是 交替 的，需要满足任意相邻字符都不同。
//
// 比方说，字符串 "010" 和 "1010" 都是交替的，但是字符串 "0100" 不是。
//
// 示例 1：
//
// 输入：s = "111000"
// 输出：2
// 解释：执行第一种操作两次，得到 s = "100011" 。
// 然后对第三个和第六个字符执行第二种操作，得到 s = "101010" 。
// 示例 2：
//
// 输入：s = "010"
// 输出：0
// 解释：字符串已经是交替的。
// 示例 3：
//
// 输入：s = "1110"
// 输出：1
// 解释：对第二个字符执行第二种操作，得到 s = "1010" 。
func minFlips(s string) int {
	// 由于可以进行类型 1 操作（循环移位），
	// 我们可以将字符串 s 复制一份接在后面，
	// 这样就可以模拟所有可能的循环移位情况。
	// 例如，如果原始字符串是 "001"，扩展后变为 "001001"，
	// 这样就可以覆盖 "001"、"010" 和 "100" 这三种循环移位的结果。
	n := len(s)
	s += s
	// ans用于记录最少的类型 2 操作次数，初始化为字符串的长度 n，因为最多的操作次数不会超过字符串的长度。
	// cnt用于记录当前窗口内需要进行类型 2 操作的次数，初始化为 0。
	ans, cnt := n, 0
	// target 是一个长度为 2 的字符串，用于存储目标交替字符串 "01"。
	target := "01"

	for r := range s {
		// target[r%2] 用于获取目标交替字符串中对应位置的字符。
		// 如果 s[r] 与目标字符不同，则需要进行一次类型 2 操作，cnt 加 1。
		if s[r] != target[r%2] {
			cnt++
		}

		// 当窗口的右边界 r 小于 n-1 时，窗口大小还未达到原始字符串的长度，继续扩展窗口。
		if r < n-1 {
			continue
		}

		//这里有两种可能的交替字符串："0101..." 和 "1010..."
		//。cnt 是将当前窗口内的字符串转换为 "0101..." 所需的操作次数，
		//n-cnt 是将当前窗口内的字符串转换为 "1010..." 所需的操作次数。
		//取 ans、cnt 和 n-cnt 中的最小值更新 ans。
		ans = min(ans, cnt, n-cnt)

		// 当窗口右边界扩展到长度为 n 后，需要将窗口左边界右移一位。
		// 如果左边界的字符在之前被计入了 cnt，则需要将 cnt 减 1。
		l := r - n + 1
		if s[l] != target[l%2] {
			cnt--
		}
	}
	return ans
}
